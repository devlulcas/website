---
title: Testando PHP com Pest
tags:
  - php
  - testes
  - pest
  - phpunit
categories:
  - testing
  - php
date: 03/02/2022
draft: false
excerpt: Uma breve introdu√ß√£o ao framework de testes Pest do ecossistema PHP
---

## üß™ UNIT TESTS - TESTES UNIT√ÅRIOS

![thumb](./thumb.png)

√â uma boa dar uma olhada na documenta√ß√£o:
[Documenta√ß√£o do Pest](https://pestphp.com/)

## Alguns sites, v√≠deos e reposit√≥rios √∫teis

- [V√≠deo do Dias de Dev](https://www.youtube.com/watch?v=1oTRpTPEyX0&ab_channel=DiasdeDev)
- [Os tr√™s tipos de testes unit√°rios](https://www.youtube.com/watch?v=W40mpZP9xQQ&t=173s&ab_channel=ContinuousDelivery)

## üßπ Prepare seu ambiente de testes

Neste caso escolhi o framework de testes `Pest` por ser capaz de rodar testes do `PHP Unit` al√©m de ter a pr√≥pria API de testes que oferece uma experi√™ncia de desenvolvimento mais agrad√°vel.

> √â v√°lido lembrar que os testes rodaram apenas em ambiente de desenvolvimento.

```bash
# Instalando o pest e iniciando
composer require pestphp/pest --dev --with-all-dependencies
./vendor/bin/pest --init
```

```bash
# Cria uma pasta para seus testes unit√°rios
mkdir tests/Unit
```

```bash
# Roda os testes
./vendor/bin/pest
```

## üßê Conven√ß√µes de nomes de testes no Pest

> No pest √© necess√°rio colocarmos um sufixo no nome dos nossos arquivos de testes. O sufixo ser√° aquele definido no arquivo phpunit.xml. Por padr√£o o sufixo √© Test.php.

```text
|tests
   |
   ---|Unit
        |
        ----|TremTest.php
```

## üßê Conven√ß√µes de nomes de testes no PHPUnit

> Quando vamos testar uma classe o padr√£o para definir o nome do teste √© a combina√ß√£o do nome da classe com a palavra "Test". N√£o precisamos nos preocupar tanto com isso no momento pois vamos estar usando o pest.

```php
// Classe
class XmlConverter {

}

// Teste
class XmlConverterTest extends PHPUnit\Framework\TestCase {

}
```

## ü¶¥ Estrutura dos testes no Pest

> No Pest podemos usar duas fun√ß√µes principais para definir um test:

```php
test('garante que true √© igual a true', function () {
    $this->assertTrue(true);
    expect(true)->toBeTrue();
});

it('garante que true √© igual a true', function () {
    $this->assertTrue(true);
    expect(true)->toBeTrue();
});
```

Basicamente a estrutura √© composta pela chamada da fun√ß√£o `test()` ou `it()` passando como par√¢metro a mensagem do teste e a fun√ß√£o que rodar√° o teste, essa fun√ß√£o estende por padr√£o as funcionalidades da classe `TestCase`. A √∫nica diferen√ßa entre as duas √© que quando usamos `it()` ele mostra a mensagem de teste com um "it" antes.

## üìú SCRIPTS √öTEIS PARA RODAR SEUS TESTES

Adicione os scripts abaixo em seu `composer.json` para facilitar a execu√ß√£o dos testes.

```json
"scripts": {
    "dev": "xdg-open 'http://localhost:3333'; php -S localhost:3333",
    "test": "./vendor/bin/pest",
    "coverage": "./vendor/bin/pest --coverage"
}
```

## üßë‚Äç‚öñÔ∏è TESTES DE PRIMEIRA ORDEM

```php
// C√≥digo
function fazedorDeCoisas(){
    return true;
}

// Teste
it("faz alguma coisa")->assertTrue(fazedorDeCoisas());

// A linha acima equivale a:
it("faz alguma coisa", function() {
    $this->assertTrue(fazedorDeCoisas());
});
```

## üê∏ PULANDO TESTES

Podemos ligar m√©todos no fim da chamada do nosso m√©todo de testes. Nesse caso estamos usando o m√©todo `skip` para pular um teste.

```php
it("faz alguma coisa", function() {
    $this->assertTrue(true);
})->skip("porque n√£o quero que este teste rode agora");
```

## üö™TESTANDO COM DIVERSAS ENTRADAS

Utilizando a ideia do m√©todo chamado no fim do `it` ou `test` podemos facilitar v√°rias outras opera√ß√µes, como a de passar m√∫ltiplas fontes de dados para testar uma funcionalidade por exemplo.

Com o m√©todo `with` n√≥s podemos passar um array que servir√° como fonte de dados para nossa fun√ß√£o de testes.

```php
it("rejeita senhas inv√°lidas", function($senha) {
    $this->assertFalse(Valida√ß√£o::senha($senha));
})->with(["12345678", "abcde", "", "k1k2", "asdf2468"]);
```

Isso funciona bem para casos simples, mas quando h√° mais entradas ou caso voc√™ goste de deixar as coisas bem separadinhas √© necess√°rio separar os datasets do seu c√≥digo de testes.

Para fazer isso podemos criar uma pasta em `/tests/Datasets` para guardas nossos datasets.

Neste caso podemos definir nosso dataset assim:

```php
// tests/Datasets/Dados.php
dataset("identificador", function() {
    return ["primeiro üé≤, segundo üé≤, terceiro üé≤"]
});

// tests/Unit/DadosTest.php
it("tem dados de verdade", function($dados) {
    $this->assertNotEmpty($dados);
})->with("identificador");
```

## ‚è∞ EXECUTE ALGO ANTES DE CADA TESTE

No Pest podemos especificar uma fun√ß√£o que ser√° executada antes de cada teste naquele determinado arquivo com a fun√ß√£o `beforeEach` que significa literalmente `antesDeCada`.

```php
// C√≥digo
function verificaSeTemUsu√°rio() {
    return true;
}

// Testes
beforeEach(function() {
    echo "Preparando o banco de dados...";
});

it("tem um usu√°rio no banco")->assertTrue(verificaSeTemUsu√°rio())
```

## ü§® ASSER√á√ïES E EXPECTATIVAS

Quando escrevemos testes unit√°rios devemos ser diretos em dizer o que esperamos que aconte√ßa quando um determinado peda√ßo de c√≥digo √© executado. Para verificar se o retorno, altera√ß√£o ou intera√ß√£o que o c√≥digo testado bate com o que esperamos podemos usar asser√ß√µes e expectativas.

### üëâ ASSER√á√ïES

Fazem verifica√ß√µes para verificar se as coisas est√£o indo como o esperado.

As asser√ß√µes de um teste no Pest s√£o m√©todos ligados ao $this, que por sua vez est√° ligado a uma classe de caso de teste. Isso acontece porque todo teste no Pest est√° ligado a uma classe de caso teste, mais especificamente a classe `PHPUnit\Framework\TestCase`. Gra√ßas a isso temos todo poder do PHPUnit em nossas m√£os de forma mais simplificada.

- [Asser√ß√µes na documenta√ß√£o do Pest](https://pestphp.com/docs/assertions)
- [Asser√ß√µes na documenta√ß√£o do PHPUnit](https://phpunit.readthedocs.io/en/9.5/assertions.html)

**Todas as asser√ß√µes do PHPUnit est√£o dispon√≠veis no Pest, para adicionar mais use a fun√ß√£o `uses(CasoDeTesteEspecifico::class);`**

```php
it("testa se true √© true mesmo", function() {
    $this->assertTrue(true);
});

it("confirma que num est√° vazio", function() {
    $this->assertNotEmpty("de fato n√£o est√° vazio");
});

// Modo curto
it("testa se true √© true mesmo")->assertTrue(true);

it("confirma que num est√° vazio")->assertNotEmpty("de fato n√£o est√° vazio");
```

### ü•∫ EXPECTATIVAS

Em adi√ß√£o as asser√ß√µes temos tamb√©m as expectativas. Essa api, fortemente inspirada no [Jest](https://jestjs.io/docs/expect), fornece uma maneira de comparar o resultado da execu√ß√£o de um c√≥digo contra uma s√©rie de expectativas.

Desta forma voc√™ oferece ao seu c√≥digo uma maneira de se sentir exatamente como voc√™ se sente em rela√ß√£o as expectativas dos seus pais. A decep√ß√£o √© inevit√°vel, mas pelo menos estamos tentando.

- [Lista de expectativas dispon√≠veis no Pest](https://pestphp.com/docs/expectations)

```php
// C√≥digo
class Filho
{
    private string profiss√£o;
    ...
    public function getProfiss√£o(): string {
        return strtolower($this->profiss√£o); // dev
    }
}

enum Profiss√£o: string
{
    case Medicina = "med";
    case Desenvolvedor = "dev";
    case FrancescoVirgolini = "la m√°quina m√°s veloz de tote italie, fiaun";
}
```

```php
// Teste
test("esperamos que sua profiss√£o seja medicina", function() {
    $filho = new Filho('eu');
    expect(filho->getProfiss√£o())->toBe(Profiss√£o::MEDICINA);
});
```

## üõ†Ô∏è PREPARO E DESMANTELAMENTO

Como j√° foi citado anteriormente n√≥s temos como executar m√©todos que s√£o executados antes de cada teste, mas temos tamb√©m m√©todos que podem ser executados depois de cada teste, antes de todos os testes e depois de todos os testes.

```php
// Rodar√° uma vez antes que cada um doss os testes daquele arquivo rodarem
beforeEach(fn() => echo "Antes de cada teste neste arquivo eu vou rodar");
```

```php
// Rodar√° uma vez depois que cada um doss os testes daquele arquivo rodarem
afterEach(fn() => echo "Depois de cada teste neste arquivo eu vou rodar");

```

```php
// Rodar√° uma vez antes que todos os testes daquele arquivo rodarem
beforeAll(fn() => echo "Antes de todos os testes neste arquivo eu vou rodar");
```

```php
// Rodar√° uma vez depois que todos os testes daquele arquivo rodarem
afterAll(fn() => echo "Depois de todos os testes neste arquivo eu vou rodar");
```

## ‚úçÔ∏è SOBRE COMO DESENVOLVER COM TDD E OS TR√äS TIPOS DE TESTES UNIT√ÅRIOS

**A escrita dos testes deve ser feita do ponto de vista de algu√©m que quer fazer algo √∫til e n√£o do ponto de vista de algu√©m que quer escrever uma fun√ß√£o que faz algo √∫til**. √â pensar em voc√™ dos pr√≥ximos 30 minutos e n√£o no voc√™ de agora.

O ponto √© separar o design da interface do seu c√≥digo do que vai estar por tr√°s dela. **N√£o pensar na implementa√ß√£o, mas sim na funcionalidade.**

A interface citada n√£o se trata necessariamente do conceito de interface como o que existe na programa√ß√£o orientada a objetos, ao de uma interface gr√°fica, aos endpoints de uma api ou aos par√¢metros de uma fun√ß√£o. Pode at√© ser qualquer uma dessas coisas, e provavelmente ser√°, mas **o que realmente importa s√£o os significados e a sem√¢ntica de como informa√ß√£o √© trocada entre dois peda√ßos de c√≥digo.**

Os pontos do seu c√≥digo onde duas partes de c√≥digo se comunicam s√£o as partes mais sens√≠veis. Ambas as partes precisam esconder alguns detalhes e simplificar a comunica√ß√£o. Essa comunica√ß√£o entre trechos de c√≥digo deve ser mais importante que os detalhes de implementa√ß√£o que eles escondem um do outro.

A melhor forma de separar onde esses detalhes de implementa√ß√£o v√£o ficar √© pensando primeiro no que eles tem que fazer e n√£o em como fazer. **Pense em quais s√£o as informa√ß√µes ess√™ncias que precisamos para realizar tal tarefa e o que precisa ser entendido para que esse c√≥digo seja usado separadamente.**

### Exemplo da fun√ß√£o que desenha uma linha

**Vamos imaginar como far√≠amos uma fun√ß√£o que desenha uma linha.**

> Podemos definir uma linha a partir de dois pares de coordenadas. Um par (x, y) para o ponto inicial e outro par para definir o ponto final.

> Podemos tamb√©m usar um vetor. Receber√≠amos um par (x, y) para o ponto inicial, um valor para o tamanho e um √¢ngulo.

Essas duas formas de desenhar uma linha s√£o perfeitamente v√°lidas, mas em nenhuma delas n√≥s realmente dizemos como desenhar uma linha.

Enquanto escrevemos o teste para tal fun√ß√£o podemos decidir qual a melhor interface para resolver o nossos problema, podemos pensar tamb√©m em qual o sistema de coordenadas usar e em como saber que a linha foi realmente desenhada direito.

Essas quest√µes n√£o s√£o um trabalho extra e desnecess√°rio, mas sim quest√µes que precisam ser respondidas para que o nosso c√≥digo de implementa√ß√£o tenha um comportamento correto.

Poder√≠amos ter as mesmas quest√µes escrevendo o c√≥digo direto, mas isso vai depender apenas de n√≥s mesmos. Fazer primeiro o teste nos imp√µe uma forma de pensar que prioriza a utilidade do que fazemos (que √© o que importa).

TDD acaba tendo a fun√ß√£o de nos fazer pensar de um jeito mais pr√°tico e objetivo, deixando os testes em si como um subproduto legal e ben√©fico, mas menos relevante que a mudan√ßa de pensamento.

### OS TIPOS DE TESTES UNIT√ÅRIOS

O conceito de encapsulamento tem um papel crucial no c√≥digo test√°vel e nossos testes n√£o devem quebrar o encapsulamento para funcionar. Os testes devem depender do mesmo n√≠vel de abstra√ß√£o que o resto da aplica√ß√£o.

Gra√ßas a isso a √∫nica coisa que nos interessa em nossos testes √© a interface publica e a sa√≠da vis√≠vel que nosso exp√µe.

- **O resultado dessa linha de pensamento √© que n√≥s ficamos ent√£o com basicamente tr√™s tipos de testes pois h√° apenas tr√™s tipos de sa√≠da que s√£o realmente interessantes.**

#### O valor retornado ou sua exce√ß√£o/mensagem de erro

O teste dessa categoria √© o mais comum. Ele vai chamar um c√≥digo, pegar o retorno ou exce√ß√£o e depois checar se o resultado era o esperado.

```php
// Fun√ß√£o
function somar($primeiroNumero, $segundoNumero) {
 return $primeiroNumero + $segundoNumero);
}

// Teste
test("resultado da soma entre dois numero √© valido", function(){
 expect(somar(2, 2))->toBe(4);
});
```

- **ü§° Um erro comum nesse tipo de teste √© testar m√∫ltiplos valores de vari√°veis que n√£o mudam o resultado de verdade.**

- **ü§° Outro erro comum √© duplicar a l√≥gica em seu teste. Algo como fazer um c√°lculo em seu teste para ver se o c√°lculo na fun√ß√£o testada est√° correto... seria como comparar o ch√£o com o ch√£o e chegar a conclus√£o que o ch√£o √© feito de ch√£o...**

#### Mudan√ßa de estado do c√≥digo que estamos testando

```php
// Teste
test("adicionar um item a pilha muda a indica√ß√£o do seu tamanho", function() {
 $roupas = new Pilha();
 $roupas->add("meias");
 expect($roupas->size)->toBe(1);
});
```

O exemplo de c√≥digo acima mostra como seria o teste de uma mudan√ßa de estado, nesse caso o tamanho da nossa pilha de itens.

- **ü§° Um erro comum que acontece nestes testes e tamb√©m em outros tipos de testes √© o de iterar dentro do teste. N√£o itere, use a ideia de zero, um ou muitos onde "muitos" pode ser qualquer n√∫mero mais que um.**

> O expert em TDD John Jagger diz que a complexidade ciclam√°tica em testes deve ser de um. Isso quer dizer que n√£o deve haver loops ou condi√ß√µes no seu teste.

#### ü•∏ Intera√ß√£o com um componente externo, um outro trecho de c√≥digo

Esses s√£o os testes que validam se o seu c√≥digo interage com outro c√≥digo da maneira que voc√™ esperava. A forma como testamos algo assim √© inserindo informa√ß√µes que est√£o sobre o controle do nosso teste.

Podemos usar mocks, spies, stubs e fakes.

- Stubs = N√£o tem intelig√™ncia, respondem sempre do mesmo jeito.
- Fake = Levemente mais inteligente que um stub, eles tem algum comportamento dentro de seu c√≥digo.

Se a intera√ß√£o com esse outro c√≥digo nos retorna um valor, n√≥s podemos dar uma trapaceada e criar algo que retorna um valor est√°tico.

- **ü§° Um erro comum nesse tipo de testes √© usar mocks que retornam mocks e que retornam mais mocks e assim criar um inferno de mocks. Criar fakes muito complexos tamb√©m √© m√° ideia.**
